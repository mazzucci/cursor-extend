# Python Utility Examples

This document shows realistic examples of Python utilities you can build with cursor-extend. Each example is ready to customize for your needs.

**Key Difference:** These are **pure Python modules** - no MCP dependency, no server setup. Cursor can import and call them directly, or you can use them in your own scripts.

---

## ðŸ” Example 1: GitHub PR Lint Checker (Shell)

**Stop context-switching.** Check your PR's CI status and fix lint errors without leaving Cursor.

### Template: `shell`

### What It Does:
- Detects your current branch
- Finds the associated PR
- Fetches lint errors from GitHub CI checks
- Returns actionable error messages Cursor can fix

### When to Use:
- You want autonomous debugging (Cursor checks CI and fixes issues)
- Your team uses GitHub Actions with lint checks
- You're tired of switching between GitHub, terminal, and editor

### Implementation:

```python
"""GitHub PR utilities - wraps gh CLI for PR status checking

Generated by cursor-extend. Pure Python module - no MCP dependency.
Use in Cursor, terminal, scripts, or notebooks.

Usage:
    from github import get_pr_lint_errors, check_gh_cli_available
    
    errors = get_pr_lint_errors()
    print(errors)
"""

import subprocess
import json
from typing import Dict, Optional


def _run_gh_command(args: list[str]) -> Dict:
    """Helper to run gh CLI commands safely"""
    try:
        result = subprocess.run(
            ["gh"] + args,
            capture_output=True,
            text=True,
            timeout=30,
            check=False
        )
        if result.returncode != 0:
            return {"error": result.stderr}
        return {"output": result.stdout, "success": True}
    except FileNotFoundError:
        return {"error": "gh CLI not installed. Install: https://cli.github.com/"}
    except subprocess.TimeoutExpired:
        return {"error": "Command timed out"}
    except Exception as e:
        return {"error": str(e)}


def get_current_branch() -> str:
    """Get the current Git branch name
    
    Returns:
        Branch name, or error message if fails
        
    Example:
        >>> branch = get_current_branch()
        >>> print(branch)
        "feature/add-new-feature"
    """
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()
    except Exception as e:
        return f"Error: {str(e)}"


def get_pr_lint_errors() -> str:
    """Get lint errors from current PR's CI checks
    
    Automatically detects your current branch, finds the PR, and
    fetches any lint failures from CI. Perfect for autonomous debugging.
    
    Returns:
        Formatted summary of lint errors, or success message if none
        
    Example:
        >>> errors = get_pr_lint_errors()
        >>> print(errors)
        "âŒ Lint errors found in PR #123: Fix auth bug
        
        ESLint
          Details: https://github.com/..."
    """
    # Get current branch
    branch = get_current_branch()
    if branch.startswith("Error"):
        return branch
    
    # Find PR for current branch
    pr_result = _run_gh_command([
        "pr", "list", 
        "--state", "open",
        "--head", branch,
        "--json", "number,title,headRefName"
    ])
    
    if "error" in pr_result:
        return f"Error finding PR: {pr_result['error']}"
    
    try:
        prs = json.loads(pr_result["output"])
        if not prs:
            return f"No open PR found for branch '{branch}'"
        
        pr_number = prs[0]["number"]
        pr_title = prs[0]["title"]
        
    except (json.JSONDecodeError, IndexError, KeyError) as e:
        return f"Error parsing PR data: {str(e)}"
    
    # Get check status for the PR
    checks_result = _run_gh_command([
        "pr", "checks", str(pr_number),
        "--json", "name,conclusion,detailsUrl"
    ])
    
    if "error" in checks_result:
        return f"Error fetching CI checks: {checks_result['error']}"
    
    try:
        checks = json.loads(checks_result["output"])
        
        # Find failed lint checks
        lint_failures = []
        for check in checks:
            name = check.get("name", "").lower()
            conclusion = check.get("conclusion", "")
            
            if "lint" in name and conclusion == "FAILURE":
                lint_failures.append({
                    "name": check["name"],
                    "url": check.get("detailsUrl", "")
                })
        
        if not lint_failures:
            return f"âœ… No lint errors found in PR #{pr_number}: {pr_title}"
        
        # Format output
        output = [f"âŒ Lint errors found in PR #{pr_number}: {pr_title}\n"]
        for failure in lint_failures:
            output.append(f"\n{failure['name']}")
            output.append(f"  Details: {failure['url']}")
            output.append("\n  Tip: Run the failing check locally to see detailed errors")
        
        return "\n".join(output)
        
    except (json.JSONDecodeError, KeyError) as e:
        return f"Error parsing check data: {str(e)}"


def check_gh_cli_available() -> str:
    """Check if GitHub CLI is installed and authenticated
    
    Returns:
        Status message indicating availability
        
    Example:
        >>> status = check_gh_cli_available()
        >>> print(status)
        "âœ… GitHub CLI is installed and authenticated"
    """
    result = _run_gh_command(["auth", "status"])
    
    if "error" in result:
        if "gh CLI not installed" in result["error"]:
            return "âŒ GitHub CLI not installed. Install: https://cli.github.com/"
        return f"âŒ {result['error']}"
    
    return "âœ… GitHub CLI is installed and authenticated"
```

### Setup:

1. **Install GitHub CLI:**
   ```bash
   # macOS
   brew install gh
   
   # Or see: https://cli.github.com/
   ```

2. **Authenticate:**
   ```bash
   gh auth login
   ```

3. **Generate with cursor-extend:**
   Ask Cursor: "Create a GitHub PR lint checker tool"

4. **Test locally:**
   ```bash
   cd .cursor/tools/github
   python -c "from github import check_gh_cli_available; print(check_gh_cli_available())"
   ```

### Usage:

**In Cursor (code execution):**
```python
from github import get_pr_lint_errors

# Cursor writes and runs this code
errors = get_pr_lint_errors()
print(errors)
# Only the output enters Cursor's context
```

**In your own scripts:**
```python
#!/usr/bin/env python3
from github import get_pr_lint_errors, get_current_branch

branch = get_current_branch()
print(f"Current branch: {branch}")

errors = get_pr_lint_errors()
if "âœ…" in errors:
    print("All checks passing!")
else:
    print("Lint errors found:")
    print(errors)
```

**In terminal:**
```bash
python -c "from github import get_pr_lint_errors; print(get_pr_lint_errors())"
```

### Conversation Example:

```
You: "Check if my PR has any lint errors"

Cursor: *Writes and runs*
  from github import get_pr_lint_errors
  print(get_pr_lint_errors())

Cursor: "Found 2 lint errors in PR #123. Let me check the details..."

Cursor: *Fixes the issues based on error output*

You: "Check again"

Cursor: *Runs the same check*
Cursor: "âœ… All lint checks passing now!"
```

---

## ðŸ“° Example 2: Hacker News API (HTTP)

**Simple external API example.** Get top tech stories from Hacker News.

### Template: `http_api`

### What It Does:
- Fetches top stories from Hacker News
- Returns title, URL, score, and author
- Demonstrates async HTTP patterns with multiple API calls

### When to Use:
- Learning Python utility development
- Testing HTTP API patterns
- Building news aggregation features
- Staying updated on tech trends

### Implementation:

```python
"""hn - Hacker News API utilities

Generated by cursor-extend. Pure Python module - no MCP dependency.
Use in Cursor, terminal, scripts, or notebooks.

Usage:
    import asyncio
    from hn import get_top_stories
    
    stories = await get_top_stories(5)
    for story in stories:
        print(story['title'])
"""

import httpx
from typing import Dict, Any


async def get_top_stories(limit: int = 10) -> list[Dict[str, Any]]:
    """Get top stories from Hacker News
    
    Args:
        limit: Number of top stories to fetch (default: 10)
        
    Returns:
        List of story dictionaries with title, url, score, author
        
    Example:
        >>> stories = await get_top_stories(5)
        >>> for story in stories:
        >>>     print(f"{story['title']} - {story['score']} points")
        "New AI Model Released - 342 points"
    """
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            # Get top story IDs
            response = await client.get("https://hacker-news.firebaseio.com/v0/topstories.json")
            response.raise_for_status()
            story_ids = response.json()[:limit]
            
            # Fetch details for each story
            stories = []
            for story_id in story_ids:
                story_response = await client.get(
                    f"https://hacker-news.firebaseio.com/v0/item/{story_id}.json"
                )
                story_response.raise_for_status()
                story_data = story_response.json()
                
                stories.append({
                    "title": story_data.get("title", ""),
                    "url": story_data.get("url", f"https://news.ycombinator.com/item?id={story_id}"),
                    "score": story_data.get("score", 0),
                    "by": story_data.get("by", "unknown"),
                    "time": story_data.get("time", 0)
                })
            
            return stories
            
    except httpx.HTTPStatusError as e:
        return [{"error": f"HTTP {e.response.status_code}"}]
    except httpx.RequestError as e:
        return [{"error": f"Failed to fetch stories - {str(e)}"}]
    except (KeyError, IndexError) as e:
        return [{"error": "Unexpected response format"}]
```

### Setup:

1. **Generate with cursor-extend:**
   Ask Cursor: "Create a Hacker News API tool"

2. **Install dependencies:**
   ```bash
   cd .cursor/tools/hn
   uv sync
   ```

3. **Test locally:**
   ```bash
   python -c "import asyncio; from hn import get_top_stories; print(asyncio.run(get_top_stories(3)))"
   ```

### Usage:

**In Cursor (code execution):**
```python
from hn import get_top_stories

# Cursor writes and runs this
stories = await get_top_stories(5)
for story in stories:
    print(f"{story['title']} - {story['score']} points")
# Only this output enters Cursor's context
```

**With data filtering (Anthropic pattern):**
```python
from hn import get_top_stories

# Get top 30 stories, but only show high-scoring ones
all_stories = await get_top_stories(30)

# Filter in code - only high-scoring stories enter context
high_scoring = [s for s in all_stories if s['score'] > 200]

# Only this small summary enters Cursor's context
print(f"Found {len(high_scoring)} stories with >200 points out of {len(all_stories)}")
for story in high_scoring[:5]:
    print(f"â€¢ {story['title']} ({story['score']} pts)")
```

**In your own scripts:**
```python
#!/usr/bin/env python3
import asyncio
from hn import get_top_stories


async def main():
    # Get top tech stories
    stories = await get_top_stories(10)
    
    print("Today's Top Tech Stories:")
    print("=" * 50)
    
    for i, story in enumerate(stories, 1):
        print(f"{i}. {story['title']}")
        print(f"   {story['score']} points by {story['by']}")
        print(f"   {story['url']}\n")


if __name__ == "__main__":
    asyncio.run(main())
```

**In terminal:**
```bash
python -c "import asyncio; from hn import get_top_stories; stories = asyncio.run(get_top_stories(3)); [print(s['title']) for s in stories]"
```

### Conversation Example:

```
You: "What are the top 3 stories on Hacker News right now?"

Cursor: *Writes and runs*
  from hn import get_top_stories
  stories = await get_top_stories(3)
  for s in stories:
      print(f"{s['title']} ({s['score']} points)")

Cursor: "Top 3 stories:
1. New AI Model Released (342 points)
2. Why Rust is Fast (287 points)  
3. Building Better APIs (201 points)"

You: "Show me only the stories with more than 250 points"

Cursor: *Writes filtering code*
Cursor: "Found 2 stories with >250 points:
â€¢ New AI Model Released (342 points)
â€¢ Why Rust is Fast (287 points)"
```

---

## ðŸŽ¯ Key Benefits of Pure Python Utilities

**1. No MCP Lock-In**
- Use in any Python script, not just Cursor
- Team members without cursor-extend can use them
- Works in notebooks, terminals, other IDEs

**2. Context Efficiency (Anthropic Pattern)**
- Large datasets processed in code, not in context
- Only `print()` statements enter Cursor's context
- Example: Fetch 1000 weather records, only show top 5

**3. Simple Testing**
- Standard Python testing (pytest, unittest)
- No MCP server to mock
- Direct function calls

**4. Portable & Shareable**
- Commit to `.cursor/tools/`
- Team gets utilities automatically
- No special setup required

---

## ðŸš€ Next Steps

1. **Start simple:** Generate one of these examples with Cursor
2. **Customize:** Modify for your specific API/CLI tool
3. **Test locally:** Run functions in terminal before using in Cursor
4. **Share with team:** Commit `.cursor/` to git

**Generate your first utility:**
```
Ask Cursor: "Create a GitHub PR lint checker using the shell template"
```

Cursor will use cursor-extend to generate a working Python module in `.cursor/tools/`!
